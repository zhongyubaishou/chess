<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>八路围棋 | EIGHT-WAY GO</title>
    
    <!-- 引入Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Montserrat:wght@300;400;700&display=swap" rel="stylesheet">
    
    <!-- 引入Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    
    <style>
        /* 全局样式 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* 艺术家风格融合：Piet Mondrian（几何抽象、原色）、Milton Glaser（简洁图标）、Josef Müller-Brockmann（网格系统） */
        :root {
            --primary-red: #e74c3c;
            --primary-yellow: #f1c40f;
            --primary-blue: #3498db;
            --primary-black: #2c3e50;
            --primary-white: #ecf0f1;
            --neutral-gray: #95a5a6;
            --board-color: #d4af37;
            --line-color: #8b4513;
        }
        
        body {
            font-family: 'Noto Sans SC', 'Montserrat', sans-serif;
            background: var(--primary-white);
            min-height: 100vh;
            display: grid;
            grid-template-rows: auto 1fr auto;
            grid-template-columns: 1fr;
            padding: 20px;
            color: var(--primary-black);
            position: relative;
            overflow-x: hidden;
        }
        
        /* Mondrian风格装饰元素 */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            background: var(--primary-red);
            z-index: -1;
        }
        
        body::after {
            content: '';
            position: fixed;
            bottom: 0;
            left: 0;
            width: 150px;
            height: 150px;
            background: var(--primary-blue);
            z-index: -1;
        }
        
        /* 几何装饰元素 */
        .geometric-decor {
            position: fixed;
            background: var(--primary-yellow);
            z-index: -1;
        }
        
        .decor-1 {
            top: 20%;
            left: 10%;
            width: 80px;
            height: 80px;
            transform: rotate(45deg);
        }
        
        .decor-2 {
            bottom: 30%;
            right: 15%;
            width: 60px;
            height: 120px;
        }
        
        /* 头部样式 - Milton Glaser风格：标志性图像与排版 */
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 20px;
            position: relative;
        }
        
        h1 {
            font-family: 'Noto Serif SC', 'Montserrat', serif;
            font-size: 3rem;
            font-weight: 700;
            color: var(--primary-black);
            margin-bottom: 10px;
            position: relative;
            display: inline-block;
            letter-spacing: -2px;
        }
        
        /* 围棋标志 - 简洁几何设计 */
        .go-logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            position: relative;
            background: var(--board-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .go-logo::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--primary-black);
            left: 20px;
        }
        
        .go-logo::after {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--primary-white);
            border: 2px solid var(--primary-black);
            right: 20px;
        }
        
        /* 副标题 */
        .subtitle {
            font-family: 'Montserrat', sans-serif;
            font-size: 1rem;
            color: var(--neutral-gray);
            letter-spacing: 4px;
            text-transform: uppercase;
        }
        
        /* 主要内容区域 - Josef Müller-Brockmann风格：网格系统 */
        main {
            display: grid;
            grid-template-columns: 1fr;
            gap: 40px;
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
        }
        
        /* 游戏容器 - 响应式网格布局 */
        .game-container {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 40px;
            align-items: start;
            justify-content: center;
        }
        
        /* 游戏内容区域 */
        .game-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        /* 棋盘样式 - Piet Mondrian几何风格 */
        .board-container {
            background: var(--board-color);
            border-radius: 0;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            border: 4px solid var(--line-color);
            position: relative;
            overflow: hidden;
        }
        
        /* 棋盘容器装饰元素 */
        .board-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 1;
        }
        
        .board-container::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.05);
            z-index: 1;
        }
        
        /* 棋盘 - 解决错位问题 */
        .board {
            width: 450px;
            height: 450px;
            background: var(--board-color);
            position: relative;
            z-index: 2;
        }
        
        /* 棋盘线条 */
        .board::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(var(--line-color) 2px, transparent 2px),
                linear-gradient(90deg, var(--line-color) 2px, transparent 2px);
            background-size: calc(100% / 7) calc(100% / 7);
            background-position: -1px -1px;
        }
        
        /* 交叉点容器 */
        .intersections {
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 3;
        }
        
        /* 交叉点 */
        .intersection {
            position: absolute;
            width: 40px;
            height: 40px;
            margin: -20px 0 0 -20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        /* 交叉点悬停效果 */
        .intersection:hover {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }
        
        /* 棋子样式 - 几何简洁设计 */
        .stone {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .stone.black {
            background: radial-gradient(circle at 35% 35%, #555, var(--primary-black));
            border: 3px solid var(--primary-black);
        }
        
        .stone.white {
            background: radial-gradient(circle at 35% 35%, #fff, #ddd);
            border: 3px solid #ccc;
        }
        
        /* 棋子悬停效果 */
        .stone:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* 游戏信息面板 - Josef Müller-Brockmann风格：清晰信息层次 */
        .game-info {
            background: var(--primary-white);
            border-radius: 0;
            padding: 30px;
            box-shadow: 4px 4px 0 var(--neutral-gray);
            width: 280px;
            min-height: 490px;
            border: 2px solid var(--primary-black);
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        /* 信息区块样式 */
        .info-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* 区块标题 - Mondrian风格几何装饰 */
        .info-section h3 {
            font-family: 'Montserrat', sans-serif;
            color: var(--primary-black);
            margin: 0;
            font-size: 1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            padding: 8px 0;
            position: relative;
            border-bottom: 3px solid var(--primary-blue);
        }
        
        .info-section h3::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            background: var(--primary-red);
            margin-right: 10px;
        }
        
        /* 玩家回合指示器 */
        .player-turn {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 1.1rem;
            font-weight: 700;
            padding: 12px 15px;
            background: var(--primary-yellow);
            border: 2px solid var(--primary-black);
            position: relative;
            overflow: hidden;
        }
        
        .player-turn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--primary-red);
        }
        
        .turn-indicator {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid var(--primary-black);
            flex-shrink: 0;
        }
        
        .turn-indicator.black {
            background: var(--primary-black);
        }
        
        .turn-indicator.white {
            background: var(--primary-white);
        }
        
        /* 得分显示 */
        .score-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(0, 0, 0, 0.02);
            border: 1px solid var(--neutral-gray);
        }
        
        .score-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .score-value {
            font-weight: 700;
            font-size: 1.4rem;
            color: var(--primary-blue);
        }
        
        /* 控制按钮 - 几何简洁设计 */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .btn {
            padding: 14px;
            border: 3px solid var(--primary-black);
            border-radius: 0;
            font-family: 'Montserrat', 'Noto Sans SC', sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--primary-black);
            transition: left 0.3s ease;
            z-index: 0;
        }
        
        .btn span, .btn i {
            position: relative;
            z-index: 1;
        }
        
        .btn-primary {
            background: var(--primary-blue);
            color: white;
        }
        
        .btn-primary:hover {
            color: var(--primary-blue);
        }
        
        .btn-primary:hover::before {
            left: 0;
        }
        
        .btn-secondary {
            background: var(--primary-red);
            color: white;
        }
        
        .btn-secondary:hover {
            color: var(--primary-red);
        }
        
        .btn-secondary:hover::before {
            left: 0;
        }
        
        .btn-success {
            background: var(--primary-yellow);
            color: var(--primary-black);
        }
        
        .btn-success:hover {
            color: var(--primary-yellow);
        }
        
        .btn-success:hover::before {
            left: 0;
        }
        
        .btn-info {
            background: var(--primary-blue);
            color: white;
        }
        
        .btn-info:hover {
            color: var(--primary-blue);
        }
        
        .btn-info:hover::before {
            left: 0;
        }
        
        /* 游戏状态提示 */
        .game-status {
            text-align: center;
            padding: 15px;
            background: var(--primary-red);
            color: white;
            border: 2px solid var(--primary-black);
            font-weight: 700;
            font-size: 1.1rem;
            letter-spacing: 1px;
            position: relative;
        }
        
        .game-status::after {
            content: '';
            position: absolute;
            bottom: -5px;
            right: -5px;
            width: 100%;
            height: 100%;
            background: var(--primary-yellow);
            border: 2px solid var(--primary-black);
            z-index: -1;
        }
        
        /* 历史记录 */
        .history {
            max-height: 180px;
            overflow-y: auto;
            padding: 15px;
            background: var(--primary-white);
            border: 2px solid var(--neutral-gray);
            font-size: 0.9rem;
            font-family: 'Montserrat', sans-serif;
        }
        
        .history-item {
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.02);
            border-left: 3px solid var(--primary-blue);
            transition: all 0.2s ease;
        }
        
        .history-item:hover {
            background: rgba(0, 0, 0, 0.05);
            transform: translateX(5px);
        }
        
        /* 页脚样式 - 简洁几何设计 */
        footer {
            margin-top: 60px;
            text-align: center;
            color: var(--primary-black);
            font-size: 0.9rem;
            font-family: 'Montserrat', sans-serif;
            padding: 20px;
            border-top: 3px solid var(--primary-black);
            position: relative;
        }
        
        footer::before {
            content: '';
            position: absolute;
            top: -3px;
            left: 0;
            width: 100px;
            height: 3px;
            background: var(--primary-red);
        }
        
        footer::after {
            content: '';
            position: absolute;
            top: -3px;
            right: 0;
            width: 100px;
            height: 3px;
            background: var(--primary-yellow);
        }
        
        /* 响应式设计 - 保持网格系统的完整性 */
        @media (max-width: 900px) {
            .game-container {
                grid-template-columns: 1fr;
                gap: 30px;
            }
            
            .game-info {
                width: 100%;
                max-width: 450px;
                margin: 0 auto;
            }
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .board {
                width: 350px;
                height: 350px;
            }
            
            .board-container {
                padding: 15px;
            }
            
            .intersection {
                width: 32px;
                height: 32px;
                margin: -16px 0 0 -16px;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 0.8rem;
                letter-spacing: 2px;
            }
            
            .go-logo {
                width: 60px;
                height: 60px;
            }
            
            .go-logo::before,
            .go-logo::after {
                width: 20px;
                height: 20px;
            }
            
            .board {
                width: 280px;
                height: 280px;
            }
            
            .board-container {
                padding: 10px;
            }
            
            .intersection {
                width: 28px;
                height: 28px;
                margin: -14px 0 0 -14px;
            }
            
            .game-info {
                padding: 20px;
                min-height: auto;
            }
            
            .btn {
                padding: 12px;
                font-size: 0.85rem;
            }
            
            /* 隐藏装饰元素以优化移动端体验 */
            .geometric-decor,
            body::before,
            body::after {
                display: none;
            }
        }
        
        /* 动画效果 */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.5);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .stone {
            animation: fadeIn 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- 几何装饰元素 -->
    <div class="geometric-decor decor-1"></div>
    <div class="geometric-decor decor-2"></div>
    
    <header>
        <div class="go-logo"></div>
        <h1>八路围棋</h1>
        <div class="subtitle">EIGHT-WAY GO</div>
    </header>
    
    <main>
        <div class="game-container">
            <div class="game-content">
                <div class="board-container">
                    <div class="board">
                        <div class="intersections" id="intersections"></div>
                    </div>
                </div>
            </div>
            
            <div class="game-info">
                <div class="info-section">
                    <h3><i class="fas fa-gamepad"></i> 游戏状态</h3>
                    <div class="game-status" id="gameStatus">黑方先行</div>
                </div>
                
                <div class="info-section">
                    <h3><i class="fas fa-user"></i> 当前回合</h3>
                    <div class="player-turn">
                        <div class="turn-indicator black" id="turnIndicator"></div>
                        <span id="currentPlayer">黑方</span>
                    </div>
                </div>
                
                <div class="info-section">
                    <h3><i class="fas fa-chart-line"></i> 得分</h3>
                    <div class="score-display">
                        <div class="score-item">
                            <i class="fas fa-circle" style="color: black;"></i>
                            <span>黑方:</span>
                            <span class="score-value" id="blackScore">0</span>
                        </div>
                    </div>
                    <div class="score-display">
                        <div class="score-item">
                            <i class="fas fa-circle" style="color: white; border: 1px solid #ccc;"></i>
                            <span>白方:</span>
                            <span class="score-value" id="whiteScore">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="info-section">
                    <h3><i class="fas fa-history"></i> 历史记录</h3>
                    <div class="history" id="history">
                        <div class="history-item">游戏开始</div>
                    </div>
                </div>
                
                <div class="info-section">
                    <h3><i class="fas fa-cog"></i> 控制</h3>
                    <div class="controls">
                        <button class="btn btn-primary" id="undoBtn"><i class="fas fa-undo"></i> 悔棋</button>
                        <button class="btn btn-secondary" id="resetBtn"><i class="fas fa-redo"></i> 重新开始</button>
                        <button class="btn btn-success" id="passBtn"><i class="fas fa-arrow-right"></i> 跳过回合</button>
                        <button class="btn btn-info" id="endGameBtn"><i class="fas fa-flag"></i> 结束游戏</button>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <footer>
        <p>&copy; 2024 八路围棋对战游戏 | 设计与开发</p>
    </footer>
    
    <script>
        // 游戏状态
        const boardSize = 8;
        let board = [];
        let currentPlayer = 'black';
        let gameHistory = [];
        let blackCaptures = 0; // 黑方提子数
        let whiteCaptures = 0; // 白方提子数
        let gameOver = false;
        let lastMove = null;
        let passCount = 0; // 连续跳过回合次数
        const komi = 6.5; // 贴目（黑棋贴给白棋的目数）
        
        // DOM元素
        const intersectionsElement = document.getElementById('intersections');
        const currentPlayerElement = document.getElementById('currentPlayer');
        const turnIndicatorElement = document.getElementById('turnIndicator');
        const gameStatusElement = document.getElementById('gameStatus');
        const blackScoreElement = document.getElementById('blackScore');
        const whiteScoreElement = document.getElementById('whiteScore');
        const historyElement = document.getElementById('history');
        const undoBtn = document.getElementById('undoBtn');
        const resetBtn = document.getElementById('resetBtn');
        const passBtn = document.getElementById('passBtn');
        const endGameBtn = document.getElementById('endGameBtn');
        
        // 初始化棋盘
        function initBoard() {
            // 初始化游戏数据
            board = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
            blackCaptures = 0;
            whiteCaptures = 0;
            currentPlayer = 'black';
            gameOver = false;
            lastMove = null;
            gameHistory = [];
            passCount = 0; // 重置连续跳过次数
            
            // 清空界面
            intersectionsElement.innerHTML = '';
            
            // 创建交叉点
            const intersectionSize = 40; // 交叉点大小
            const spacing = 100 / (boardSize - 1); // 交叉点间距百分比
            
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    intersection.dataset.row = row;
                    intersection.dataset.col = col;
                    
                    // 设置交叉点位置
                    const left = (col * spacing) + '%';
                    const top = (row * spacing) + '%';
                    intersection.style.left = left;
                    intersection.style.top = top;
                    
                    // 添加点击事件
                    intersection.addEventListener('click', () => handleIntersectionClick(row, col));
                    
                    intersectionsElement.appendChild(intersection);
                }
            }
            
            // 更新UI
            updateUI();
            
            // 重置历史记录
            historyElement.innerHTML = '<div class="history-item">游戏开始</div>';
        }
        
        // 检查是否是自杀式落子（禁入点）
        function isSuicideMove(row, col, player) {
            // 临时落子
            board[row][col] = player;
            
            // 检查新形成的棋组是否有气
            const group = findGroup(row, col);
            const hasLiberties = getLiberties(group) > 0;
            
            // 检查是否能提走对方棋子
            const opponent = player === 'black' ? 'white' : 'black';
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            let canCapture = false;
            
            for (const [dx, dy] of directions) {
                const newRow = row + dx;
                const newCol = col + dy;
                
                if (isValidPosition(newRow, newCol) && board[newRow][newCol] === opponent) {
                    const opponentGroup = findGroup(newRow, newCol);
                    if (getLiberties(opponentGroup) === 0) {
                        canCapture = true;
                        break;
                    }
                }
            }
            
            // 恢复棋盘
            board[row][col] = null;
            
            // 如果没有气且不能提子，则是自杀式落子
            return !hasLiberties && !canCapture;
        }
        
        // 处理交叉点点击
        function handleIntersectionClick(row, col) {
            if (gameOver || board[row][col] !== null) return;
            
            // 检查禁入点
            if (isSuicideMove(row, col, currentPlayer)) {
                gameStatusElement.textContent = '禁入点！不允许落子';
                return;
            }
            
            // 保存当前状态到历史记录
            saveGameState();
            
            // 落子
            board[row][col] = currentPlayer;
            placeStone(row, col, currentPlayer);
            
            // 检查提子
            const capturedStones = captureStones(row, col);
            
            // 检查打劫
            if (capturedStones.length === 1 && lastMove && 
                lastMove.captured.length === 1 && 
                lastMove.captured[0].row === row && lastMove.captured[0].col === col &&
                board[lastMove.row][lastMove.col] === currentPlayer) {
                // 打劫，不允许落子
                removeStone(row, col);
                board[row][col] = null;
                gameStatusElement.textContent = '打劫！不允许立即回提';
                return;
            }
            
            // 更新提子数（得分）
            updateCaptures(capturedStones);
            
            // 记录最后一步
            lastMove = {
                row: row,
                col: col,
                player: currentPlayer,
                captured: capturedStones
            };
            
            // 更新历史记录
            addHistoryItem(currentPlayer === 'black' ? '黑方' : '白方', row, col, capturedStones.length);
            
            // 切换玩家
            switchPlayer();
        }
        
        // 放置棋子
        function placeStone(row, col, player) {
            const intersection = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const stone = document.createElement('div');
            stone.className = `stone ${player}`;
            intersection.appendChild(stone);
        }
        
        // 移除棋子
        function removeStone(row, col) {
            const intersection = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const stone = intersection.querySelector('.stone');
            if (stone) {
                stone.remove();
            }
        }
        
        // 检查提子
        function captureStones(row, col) {
            const opponent = currentPlayer === 'black' ? 'white' : 'black';
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            const capturedStones = [];
            
            // 检查四个方向的对手棋子
            for (const [dx, dy] of directions) {
                const newRow = row + dx;
                const newCol = col + dy;
                
                if (isValidPosition(newRow, newCol) && board[newRow][newCol] === opponent) {
                    const group = findGroup(newRow, newCol);
                    if (getLiberties(group) === 0) {
                        // 提子
                        for (const [groupRow, groupCol] of group) {
                            board[groupRow][groupCol] = null;
                            removeStone(groupRow, groupCol);
                            capturedStones.push({ row: groupRow, col: groupCol });
                        }
                    }
                }
            }
            
            return capturedStones;
        }
        
        // 查找棋子组
        function findGroup(row, col) {
            const player = board[row][col];
            const group = [];
            const visited = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false));
            const queue = [{ row, col }];
            
            visited[row][col] = true;
            
            while (queue.length > 0) {
                const { row, col } = queue.shift();
                group.push([row, col]);
                
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                for (const [dx, dy] of directions) {
                    const newRow = row + dx;
                    const newCol = col + dy;
                    
                    if (isValidPosition(newRow, newCol) && !visited[newRow][newCol] && board[newRow][newCol] === player) {
                        visited[newRow][newCol] = true;
                        queue.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            return group;
        }
        
        // 计算气
        function getLiberties(group) {
            const visited = new Set();
            let liberties = 0;
            
            for (const [row, col] of group) {
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                for (const [dx, dy] of directions) {
                    const newRow = row + dx;
                    const newCol = col + dy;
                    const key = `${newRow},${newCol}`;
                    
                    if (isValidPosition(newRow, newCol) && !visited.has(key)) {
                        if (board[newRow][newCol] === null) {
                            liberties++;
                        }
                        visited.add(key);
                    }
                }
            }
            
            return liberties;
        }
        
        // 计算围空
        function calculateTerritory() {
            const visited = Array(boardSize).fill(null).map(() => Array(boardSize).fill(false));
            let blackTerritory = 0;
            let whiteTerritory = 0;
            
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === null && !visited[row][col]) {
                        // 找到一个空点，检查它属于谁的领地
                        const territory = findTerritory(row, col, visited);
                        if (territory.owner === 'black') {
                            blackTerritory += territory.size;
                        } else if (territory.owner === 'white') {
                            whiteTerritory += territory.size;
                        }
                    }
                }
            }
            
            return { black: blackTerritory, white: whiteTerritory };
        }
        
        // 查找领地
        function findTerritory(startRow, startCol, visited) {
            const queue = [{ row: startRow, col: startCol }];
            const territory = [];
            const owners = new Set();
            
            visited[startRow][startCol] = true;
            
            while (queue.length > 0) {
                const { row, col } = queue.shift();
                territory.push({ row, col });
                
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                for (const [dx, dy] of directions) {
                    const newRow = row + dx;
                    const newCol = col + dy;
                    
                    if (isValidPosition(newRow, newCol)) {
                        if (board[newRow][newCol] === null && !visited[newRow][newCol]) {
                            visited[newRow][newCol] = true;
                            queue.push({ row: newRow, col: newCol });
                        } else if (board[newRow][newCol] !== null) {
                            owners.add(board[newRow][newCol]);
                        }
                    }
                }
            }
            
            // 如果领地只被一方包围，则属于该方
            let owner = null;
            if (owners.size === 1) {
                owner = [...owners][0];
            }
            
            return { size: territory.length, owner };
        }
        
        // 检查位置是否有效
        function isValidPosition(row, col) {
            return row >= 0 && row < boardSize && col >= 0 && col < boardSize;
        }
        
        // 切换玩家
        function switchPlayer() {
            currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
            passCount = 0; // 重置连续跳过次数
            updateUI();
            gameStatusElement.textContent = `${currentPlayer === 'black' ? '黑方' : '白方'}回合`;
        }
        
        // 更新提子数（得分）
        function updateCaptures(capturedStones) {
            if (capturedStones.length > 0) {
                if (currentPlayer === 'black') {
                    blackCaptures += capturedStones.length;
                } else {
                    whiteCaptures += capturedStones.length;
                }
                updateScoreDisplay();
            }
        }
        
        // 更新得分显示
        function updateScoreDisplay() {
            if (gameOver) {
                // 游戏结束时显示最终得分
                const { black, white, territory } = calculateFinalScore();
                blackScoreElement.textContent = `${black.toFixed(1)} (围空: ${territory.black}, 提子: ${blackCaptures})`;
                whiteScoreElement.textContent = `${white.toFixed(1)} (围空: ${territory.white}, 提子: ${whiteCaptures})`;
            } else {
                // 游戏进行中显示提子数
                blackScoreElement.textContent = `${blackCaptures} 提子`;
                whiteScoreElement.textContent = `${whiteCaptures} 提子`;
            }
        }
        
        // 添加历史记录
        function addHistoryItem(player, row, col, captured) {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            
            if (row === -1 && col === -1) {
                // 跳过回合
                historyItem.textContent = `${player} 跳过回合`;
            } else {
                // 将行列转换为围棋坐标（A-H, 1-8）
                const colLetter = String.fromCharCode(65 + col);
                const rowNumber = boardSize - row;
                
                let text = `${player} 在 ${colLetter}${rowNumber} 落子`;
                if (captured > 0) {
                    text += `，提子 ${captured} 颗`;
                }
                
                historyItem.textContent = text;
            }
            
            historyElement.appendChild(historyItem);
            historyElement.scrollTop = historyElement.scrollHeight;
        }
        
        // 保存游戏状态
        function saveGameState() {
            const state = {
                board: board.map(row => [...row]),
                currentPlayer: currentPlayer,
                blackCaptures: blackCaptures,
                whiteCaptures: whiteCaptures,
                gameOver: gameOver,
                lastMove: lastMove,
                passCount: passCount
            };
            gameHistory.push(state);
        }
        
        // 悔棋
        function undoMove() {
            if (gameHistory.length === 0) return;
            
            const prevState = gameHistory.pop();
            board = prevState.board;
            currentPlayer = prevState.currentPlayer;
            blackCaptures = prevState.blackCaptures;
            whiteCaptures = prevState.whiteCaptures;
            gameOver = prevState.gameOver;
            lastMove = prevState.lastMove;
            passCount = prevState.passCount;
            
            // 重新渲染棋盘
            renderBoard();
            
            // 更新UI
            updateUI();
            
            // 更新历史记录显示
            const historyItems = historyElement.querySelectorAll('.history-item');
            if (historyItems.length > 1) {
                historyItems[historyItems.length - 1].remove();
            }
        }
        
        // 重新渲染棋盘
        function renderBoard() {
            // 清空所有棋子
            const intersections = document.querySelectorAll('.intersection');
            intersections.forEach(intersection => {
                const stone = intersection.querySelector('.stone');
                if (stone) {
                    stone.remove();
                }
            });
            
            // 重新放置所有棋子
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] !== null) {
                        placeStone(row, col, board[row][col]);
                    }
                }
            }
        }
        
        // 更新UI
        function updateUI() {
            currentPlayerElement.textContent = currentPlayer === 'black' ? '黑方' : '白方';
            turnIndicatorElement.className = `turn-indicator ${currentPlayer}`;
            updateScoreDisplay();
        }
        
        // 重新开始游戏
        function resetGame() {
            initBoard();
        }
        
        // 跳过回合
        function passTurn() {
            if (gameOver) return;
            
            saveGameState();
            addHistoryItem(currentPlayer === 'black' ? '黑方' : '白方', -1, -1, 0);
            
            // 增加连续跳过次数
            passCount++;
            
            // 如果双方连续跳过，则游戏结束
            if (passCount >= 2) {
                endGame();
                return;
            }
            
            switchPlayer();
        }
        
        // 计算最终得分
        function calculateFinalScore() {
            const territory = calculateTerritory();
            
            // 日韩规则：目数 = 围空 + 提子
            const blackScore = territory.black + blackCaptures;
            const whiteScore = territory.white + whiteCaptures + komi;
            
            return { black: blackScore, white: whiteScore, territory };
        }
        
        // 判定胜负
        function determineWinner(blackScore, whiteScore) {
            if (blackScore > whiteScore) {
                return { winner: 'black', margin: blackScore - whiteScore };
            } else if (whiteScore > blackScore) {
                return { winner: 'white', margin: whiteScore - blackScore };
            } else {
                return { winner: 'draw', margin: 0 };
            }
        }
        
        // 结束游戏
        function endGame() {
            gameOver = true;
            
            // 计算最终得分
            const { black, white, territory } = calculateFinalScore();
            const { winner, margin } = determineWinner(black, white);
            
            // 更新游戏状态显示
            let statusText = '';
            if (winner === 'draw') {
                statusText = '游戏平局！';
            } else {
                const winnerText = winner === 'black' ? '黑方' : '白方';
                statusText = `${winnerText} 获胜！领先 ${margin.toFixed(1)} 目`;
            }
            gameStatusElement.textContent = statusText;
            
            // 添加终局历史记录
            const territoryInfo = `黑方围空: ${territory.black} 目 | 白方围空: ${territory.white} 目`;
            const capturesInfo = `黑方提子: ${blackCaptures} 颗 | 白方提子: ${whiteCaptures} 颗`;
            const finalScoreInfo = `最终得分: 黑方 ${black.toFixed(1)} 目 | 白方 ${white.toFixed(1)} 目`;
            
            addHistoryItem('游戏结束', -1, -1, 0);
            addHistoryItem(territoryInfo, -1, -1, 0);
            addHistoryItem(capturesInfo, -1, -1, 0);
            addHistoryItem(finalScoreInfo, -1, -1, 0);
            
            // 更新得分显示
            updateScoreDisplay();
        }
        
        // 事件监听器
        undoBtn.addEventListener('click', undoMove);
        resetBtn.addEventListener('click', resetGame);
        passBtn.addEventListener('click', passTurn);
        endGameBtn.addEventListener('click', endGame);
        
        // 初始化游戏
        initBoard();
    </script>
</body>
</html>